---
title: 最小生成集问题
date: 2019-10-05 10:04:29
updated: 2019-10-05
categories: 解命题
tags:
  - 算法
  - 代数结构
---

<br/>

# 起源

七段数码管是这样的东西: 
![七段数码管](https://ss0.bdstatic.com/6Ox1bjeh1BF3odCf/it/u=2686736431,1813808410&fm=74&app=80&f=JPEG&size=f121,140?sec=1880279984&t=70d12f4062c45b1ef0340dc8a7db39e4)

当我们想要显示一位数字的时候，实际就是去点亮七段LED中的某几段，比如数字1就是bc，2就是abged，以此类推……

为了方便写单片机程序，我们需要做个编码(补上一个不使用的比特h): 
```text
DIG | a b c d e f g h | HEX
----|-----------------|------
'0' | 1 1 1 1 1 1 0 0 | 0xFC
'1' | 0 1 1 0 0 0 0 0 | 0x60
'2' | 1 1 0 1 1 0 1 0 | 0xDA
'3' | 1 1 1 1 0 0 1 0 | 0xF2
'4' | 0 1 1 0 0 1 1 0 | 0x66
'5' | 1 0 1 1 0 1 1 0 | 0xB6
'6' | 1 0 1 1 1 1 1 0 | 0xBE
'7' | 1 1 1 0 0 0 0 0 | 0xE0
'8' | 1 1 1 1 1 1 1 0 | 0xFE
'9' | 1 1 1 1 0 1 1 0 | 0xF6
```

如此之后我们可以发现，其实并不用对每个需要显示的图案都去**逐位列举**以计算编码，如果我们知道'2'和'5'的编码，我们就可以直接通过按位或运算得到'8'的编码，ie. 0xDA | 0xB6 == 0xFE

于是现在的问题就是，我们**最少选择几个、选择哪几个基本编码，就可以通过常用的位运算得到其他的编码**，下面进一步抽象并给出这个问题的数学描述

# 描述

给定数字0~9的二进制表示集合`N`，给定算子集合`OP = { NOT, OR, AND, XOR }`，求`N`在`OP`下的最小生成集

一般化扩展: 给定一个二进制数的集合`N = {N1, N2, ..., Nn}`，给定一个`N`上算子的集合`OP = {OP1, OP2, ..., OPk}`，求`N`在`OP`下的最小生成集

# 解

目前没有想到合理的多项式时间算法，暂时先放个暴力解: 

{% include_code lang:python MGS_bf.py %}
